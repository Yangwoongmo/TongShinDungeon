using System.Collections;
using System.Collections.Generic;
using System.IO;
using Newtonsoft.Json.Linq;
using UnityEngine;

public class MapGenerator : MonoBehaviour
{
    private const float xScale = 10.24f;
    private const int FloorMaterialTotalCount = 16;

    private readonly float[] dz = { 5.12f, 0, -5.12f, 0 };
    private readonly float[] dx = { 0, 5.12f, 0, -5.12f };
    private readonly float[] angle = { 0, 90, 180, 270 };

    public GameObject mapRootPrefab;
    public Transform decoParent;
    public Floor[] floors;
    public GameObject[] walls;
    public GameObject[] mapDecorations;
    public ItemHolder itemHolderPrefab;
    public ItemHolder rewardPrefab;
    public MonsterSpawn monsterSpawnPrefab;
    public DialogEventObject dialogEventObjectPrefab;
    public string jsonFileName;
    public int stageId;
    public int mapVersion;

    public Material[] floorMaterials;
    public List<TwoDimensionListForInspector<Material>> wallMaterials;
    public Material transparentWallMaterial;

    public StartPointInfo startPointInfo;
    public ThornFloorInfo[] thornFloorInfos;
    public ItemHolderInfo[] itemHolderInfos;
    public MonsterSpawnInfo[] monsterSpawnInfos;
    public TriggerObjectInfo[] triggerObjectInfos;
    public TimerObjectInfo[] timerObjectInfos;
    public BlinkPointInfo blinkPointInfo;
    public PortalInfo[] portalInfos;
    public SwitchInfo[] switchInfos;
    public IronBarInfo[] ironBarInfos;
    public TutorialPointInfo[] tutorialInfos;
    public DialogEventInfo[] dialogEventInfos;

    public RandomItemDistributor itemDistributor;
    public RandomMonsterDistributor monsterDistributor;
    public MapPrototypeSceneController mapController;
    public PlayerInteractionController interactionController;
    public Transform playerTransform;
    
    private Transform parent;

    private long autoGeneratedId = 0;

    // N, E, S, W
    // -> N
    public void generateMap()
    {
#if UNITY_EDITOR
        if (gameObject.transform.childCount > 0)
        {
            return;
        }

        autoGeneratedId = 0;
        parent = Instantiate(mapRootPrefab, this.gameObject.transform).transform;
        parent.GetComponent<PlayerInteractionMediator>().SetPlayerPosition(playerTransform);

        mapController.SetMapParent(this.gameObject.transform);
        mapController.SetStartFloorMediator(parent.GetComponent<StartFloorChangeMediator>());
        interactionController.SetMediatorAndStorage(parent.gameObject);

        JObject tiles = getTilesFromJson();
        JObject bound = tiles["bounds"] as JObject;
        int width = (int)bound["width"];
        int height = (int)bound["height"];
        int x0 = (int)bound["x0"];
        int y0 = (int)bound["y0"];
        // For caching generated floors and walls.
        FloorModel[,] floorModels = new FloorModel[height, width];

        // Step 1. Generating basic map (Floors and Walls)
        JArray rows = tiles["rows"] as JArray;
        for (int i = 0; i < rows.Count; i++)
        {
            JObject row = rows[i] as JObject;
            int y = height - 1 - ((int)row["y"] - y0);
            int x = (int)row["start"];
            JArray tileDatas = row["tdata"] as JArray;

            for (int j = 0; j < tileDatas.Count; j++)
            {
                int currentX = x + j;
                JObject tileData = tileDatas[j] as JObject;
                if (tileData == null)
                {
                    continue;
                }

                float floorZ = currentX * xScale;
                float floorX = y * xScale;

                Floor currentFloor = null;
                int currentFloorMaterialIndex = -1;

                if (tileData.ContainsKey("t"))
                {
                    int tileIndex = 0;
                    if (tileData.ContainsKey("m") && (int)tileData["m"] == 97)
                    {
                        tileIndex = 1;
                    }
                    currentFloor = Instantiate(floors[tileIndex], parent);

                    string floorId = "F" + autoGeneratedId++;
                    if (mapVersion > 0)
                    {
                        floorId += "v" + mapVersion;
                    }
                    currentFloor.SetId(floorId);
                    currentFloor.gameObject.transform.localPosition = new Vector3(floorX, 0, floorZ);

                    int topFloorMaterial = -1;
                    FloorModel topFloorModel;
                    if (y > 0 && (topFloorModel = floorModels[y - 1, currentX]) != null)
                    {                     
                        if (topFloorModel.bottom != null)
                        {
                            Wall topWall = topFloorModel.bottom.gameObject.transform.parent.GetChild(1 - topFloorModel.bottomChildIndex).GetComponent<Wall>();
                            currentFloor.SetWall(topWall, 3);
                        }
                        if (topFloorModel.tile != null)
                        {
                            topFloorModel.tile.SetFloor(currentFloor, 1);
                            currentFloor.SetFloor(topFloorModel.tile, 3);
                            topFloorMaterial = topFloorModel.floorMaterialIndex;
                        }
                    }

                    int leftFloorMaterial = -1;
                    FloorModel leftFloorModel;
                    if (currentX > 0 && (leftFloorModel = floorModels[y, currentX - 1]) != null)
                    {
                        if (leftFloorModel.right != null)
                        {
                            Wall leftWall = leftFloorModel.right.gameObject.transform.parent.GetChild(1 - leftFloorModel.rightChildIndex).GetComponent<Wall>();
                            currentFloor.SetWall(leftWall, 2);
                        }
                        if (leftFloorModel.tile != null)
                        {
                            leftFloorModel.tile.SetFloor(currentFloor, 0);
                            currentFloor.SetFloor(leftFloorModel.tile, 2);
                            leftFloorMaterial = leftFloorModel.floorMaterialIndex;
                        }
                    }

                    List<int> randomMaterialIndexList = new List<int>();
                    for (int m = 0; m < FloorMaterialTotalCount; m++)
                    {
                        if (m != leftFloorMaterial && m != topFloorMaterial)
                        {
                            randomMaterialIndexList.Add(m);
                        }
                    }
                    currentFloorMaterialIndex = randomMaterialIndexList[Random.Range(0, randomMaterialIndexList.Count)];
                    currentFloor.SetFloorMaterial(floorMaterials[currentFloorMaterialIndex]);
                    currentFloor.materialMainId = currentFloorMaterialIndex;
                }

                Wall currentRightWall = null;
                int rightWallChildIndex = 1;
                int rightColorCode = -1;
                int rightColorSubCode = -1;
                if (tileData.ContainsKey("r"))
                {
                    int right = (int)tileData["r"];
                    WallType wallType = getWallTypeFromEdgeType(right);
                    GameObject rightWall = Instantiate(walls[wallType.prefabIndex], parent);
                    float wallZ = floorZ + dz[0];
                    float wallX = floorX + dx[0];
                    rightWall.gameObject.transform.localPosition = new Vector3(wallX, rightWall.gameObject.transform.localPosition.y, wallZ);
                    rightWall.gameObject.transform.localEulerAngles = new Vector3(0, angle[0] + (wallType.isReverse ? 180 : 0), 0);
                    rightWallChildIndex = wallType.isReverse ? 0 : 1;
                    currentRightWall = rightWall.transform.GetChild(rightWallChildIndex).GetComponent<Wall>();
                    SetWallObjectId(rightWall);

                    int prefabIndex = wallType.prefabIndex;
                    if (prefabIndex == 0)
                    {
                        int rightColor = tileData.ContainsKey("rc") ? (int)tileData["rc"] : 1;
                        rightColorCode = GetMaterialCode(rightColor);
                    }
                    else if (prefabIndex == 1 || prefabIndex == 5 || prefabIndex == 8)
                    {
                        rightColorCode = 0;
                    }

                    if (rightColorCode >= 0)
                    {
                        FloorModel top;
                        int topRightSubCode = -1;
                        if (y > 0 && (top = floorModels[y - 1, currentX]) != null && top.right != null)
                        {
                            int topRightColor = top.rightColorCode;
                            if (topRightColor == rightColorCode)
                            {
                                topRightSubCode = top.rightColorSubCode;
                            }
                        }
                        List<int> randomSubColorIndexList = new List<int>();
                        for (int c = 0; c < wallMaterials[rightColorCode].GetList().Count; c++)
                        {
                            if (c != topRightSubCode)
                            {
                                randomSubColorIndexList.Add(c);
                            }
                        }

                        rightColorSubCode = randomSubColorIndexList[Random.Range(0, randomSubColorIndexList.Count)];
                    }
                    SetWallMaterial(rightWall, rightColorCode, rightColorSubCode);

                    if (currentFloor != null)
                    {
                        currentFloor.SetWall(currentRightWall, 0);
                    }
                }

                Wall currenBottomtWall = null;
                int bottomWallChildIndex = 1;
                int bottomColorCode = -1;
                int bottomColorSubCode = -1;
                if (tileData.ContainsKey("b"))
                {
                    int bottom = (int)tileData["b"];
                    WallType wallType = getWallTypeFromEdgeType(bottom);
                    GameObject bottomWall = Instantiate(walls[wallType.prefabIndex], parent);
                    float wallZ = floorZ + dz[1];
                    float wallX = floorX + dx[1];
                    bottomWall.gameObject.transform.localPosition = new Vector3(wallX, bottomWall.gameObject.transform.localPosition.y, wallZ);
                    bottomWall.gameObject.transform.localEulerAngles = new Vector3(0, angle[1] + (wallType.isReverse ? 180 : 0), 0);
                    bottomWallChildIndex = wallType.isReverse ? 0 : 1;
                    currenBottomtWall = bottomWall.transform.GetChild(bottomWallChildIndex).GetComponent<Wall>();
                    SetWallObjectId(bottomWall);

                    int prefabIndex = wallType.prefabIndex;
                    if (prefabIndex == 0)
                    {
                        int bottomColor = tileData.ContainsKey("bc") ? (int)tileData["bc"] : 1;
                        bottomColorCode = GetMaterialCode(bottomColor);
                    }
                    else if (prefabIndex == 1 || prefabIndex == 5 || prefabIndex == 8)
                    {
                        bottomColorCode = 0;
                    }

                    if (bottomColorCode >= 0)
                    {
                        FloorModel left;
                        int leftBottomSubCode = -1;
                        if (currentX > 0 && (left = floorModels[y, currentX - 1]) != null && left.bottom != null)
                        {
                            int leftBottomColor = left.bottomColorCode;
                            if (leftBottomColor == bottomColorCode)
                            {
                                leftBottomSubCode = left.bottomColorSubCode;
                            }
                        }
                        List<int> randomSubColorIndexList = new List<int>();
                        for (int c = 0; c < wallMaterials[bottomColorCode].GetList().Count; c++)
                        {
                            if (c != leftBottomSubCode)
                            {
                                randomSubColorIndexList.Add(c);
                            }
                        }

                        bottomColorSubCode = randomSubColorIndexList[Random.Range(0, randomSubColorIndexList.Count)];
                    }
                    SetWallMaterial(bottomWall, bottomColorCode, bottomColorSubCode);

                    if (currentFloor != null)
                    {
                        currentFloor.SetWall(currenBottomtWall, 1);
                    }
                }

                floorModels[y, currentX] = new FloorModel(
                    currentFloor, 
                    currentRightWall, 
                    currenBottomtWall, 
                    rightWallChildIndex, 
                    bottomWallChildIndex, 
                    currentFloorMaterialIndex,
                    rightColorCode,
                    rightColorSubCode,
                    bottomColorCode,
                    bottomColorSubCode
                );
            }
        }

        // Step 2. Set Floors (trap, item, monster, blink, timer, trigger)

        // Set Start Floor
        Floor startFloor = GetFloorFromModels(startPointInfo.floorPosition, x0, y0, height, floorModels);
        mapController.SetStartFloor(startFloor, startPointInfo.startDirection);

        // Set thorn floor (popup/hide time, offset)
        for (int i = 0; i < thornFloorInfos.Length; i++)
        {
            ThornFloorInfo info = thornFloorInfos[i];
            for (int j = 0; j < info.floorPositions.Length; j++)
            {
                FloorPos pos = info.floorPositions[j];
                Thorn thorn = GetFloorFromModels(pos, x0, y0, height, floorModels).transform.GetChild(0).GetComponent<Thorn>();
                thorn.SetupThornForGenerating(info.popupDuration, info.hideDuration, info.startOffsets[j], info.isActivatedByTrigger);
            }
        }

        int totalItemsCount = itemHolderInfos.Length;
        int fixedItemsCount = 0;
        for (int i = 0; i < itemHolderInfos.Length; i++)
        {
            if (itemHolderInfos[i].isFixedItem)
            {
                fixedItemsCount++;
            }
        }

        // Set Item distribution
        itemDistributor.ClearItemGroups(totalItemsCount - fixedItemsCount, fixedItemsCount);
        for (int i = 0; i < itemHolderInfos.Length; i++)
        {
            ItemHolderInfo info = itemHolderInfos[i];
            ItemHolder[] itemHolders = new ItemHolder[info.floorPositions.Length];
            for (int j = 0; j < info.floorPositions.Length; j++)
            {
                FloorPos pos = info.floorPositions[j];
                Floor floor = GetFloorFromModels(pos, x0, y0, height, floorModels);
                ItemHolder holder = Instantiate(itemHolderPrefab, floor.transform);
                floor.SetInteractionObject(holder);
                if (info.isFixedItem)
                {
                    int itemId = info.itemIds.Length > 0 ? info.itemIds[0] : 0;
                    int gold = info.golds.Length > 0 ? info.golds[0] : 0;
                    holder.SetItemInfo(itemId, gold, info.isFixedItem);
                }
                
                itemHolders[j] = holder;

            }
            itemDistributor.AddItemHolderToGroup(info.groupId, info.isFixedItem, itemHolders, info.itemIds, info.golds);
        }

        int totalMonsterCount = monsterSpawnInfos.Length;
        int fixedMonsterCount = 0;
        for (int i = 0; i < monsterSpawnInfos.Length; i++)
        {
            if (monsterSpawnInfos[i].isFixedMonster)
            {
                fixedMonsterCount++;
            }
        }

        // Set Monster distribution
        monsterDistributor.ClearSpawns(totalMonsterCount - fixedMonsterCount, fixedMonsterCount);
        for (int i = 0; i < monsterSpawnInfos.Length; i++)
        {
            MonsterSpawnInfo info = monsterSpawnInfos[i];
            MonsterSpawn[] spawns = new MonsterSpawn[info.floorPositions.Length];
            for (int j = 0; j < info.floorPositions.Length; j++)
            {
                FloorPos pos = info.floorPositions[j];
                Floor floor = GetFloorFromModels(pos, x0, y0, height, floorModels);
                MonsterSpawn spawn = Instantiate(monsterSpawnPrefab, floor.transform);
                ItemHolder reward = Instantiate(rewardPrefab, floor.transform);

                spawn.SetReward(reward);
                if (info.isFixedMonster)
                {
                    spawn.SetMonsterInfo(info.monsterIds[0], info.isFixedMonster, info.isBossAttack);
                }

                floor.SetInteractionObject(spawn);
                spawns[j] = spawn;
            }
            monsterDistributor.AddMonsterGroup(info.groupId, info.isFixedMonster, info.monsterIds, spawns);
        }

        // Set trigger object
        for (int i = 0; i < triggerObjectInfos.Length; i++)
        {
            TriggerObjectInfo info = triggerObjectInfos[i];
            Floor floor = GetFloorFromModels(info.floorPos, x0, y0, height, floorModels);
            TriggerObject trigger = floor.gameObject.AddComponent<TriggerObject>();
            floor.SetTriggerObject(trigger);

            Floor unLockFloor = GetFloorFromModels(info.unLockFloorPos, x0, y0, height, floorModels);
            TriggerUnLockObject unLock = unLockFloor.gameObject.AddComponent<TriggerUnLockObject>();
            unLock.SetTriggerObject(trigger);
            unLockFloor.SetTriggerObject(unLock);

            Thorn[] thorns = new Thorn[info.thornFloorPositions.Length];
            for (int j = 0; j < thorns.Length; j++)
            {
                FloorPos thornPos = info.thornFloorPositions[j];
                thorns[j] = GetFloorFromModels(thornPos, x0, y0, height, floorModels).transform.GetChild(0).GetComponent<Thorn>();
            }

            IronBar[] ironBars = new IronBar[info.ironBarPositions.Length * 2];
            for (int j = 0; j < info.ironBarPositions.Length; j++)
            {
                WallPos wallPos = info.ironBarPositions[j];
                Transform wall = GetFloorFromModels(wallPos.floorPos, x0, y0, height, floorModels).GetWall((int)wallPos.wallDirection).transform.parent;
                ironBars[2 * j] = wall.GetChild(0).GetComponent<IronBar>();
                ironBars[2 * j + 1] = wall.GetChild(1).GetComponent<IronBar>();
            }

            trigger.SetupTriggerInfo(thorns, ironBars);
        }

        // Set timer object
        for (int i = 0; i < timerObjectInfos.Length; i++)
        {
            TimerObjectInfo info = timerObjectInfos[i];
            Floor floor = GetFloorFromModels(info.floorPos, x0, y0, height, floorModels);
            TimerObject timer = floor.gameObject.AddComponent<TimerObject>();
            floor.SetTriggerObject(timer);

            Thorn[] thorns = new Thorn[info.thornFloorPositions.Length];
            for (int j = 0; j < thorns.Length; j++)
            {
                FloorPos thornPos = info.thornFloorPositions[j];
                thorns[j] = GetFloorFromModels(thornPos, x0, y0, height, floorModels).transform.GetChild(0).GetComponent<Thorn>();
            }

            IronBar[] ironBars = new IronBar[info.ironBarPositions.Length * 2];
            for (int j = 0; j < info.ironBarPositions.Length; j++)
            {
                WallPos wallPos = info.ironBarPositions[j];
                Transform wall = GetFloorFromModels(wallPos.floorPos, x0, y0, height, floorModels).GetWall((int)wallPos.wallDirection).transform.parent;
                ironBars[2 * j] = wall.GetChild(0).GetComponent<IronBar>();
                ironBars[2 * j + 1] = wall.GetChild(1).GetComponent<IronBar>();
            }

            timer.SetupTimerInfo(thorns, ironBars, info.timeToStopTimer);
        }

        // Set blink point
        for (int i = 0; i < blinkPointInfo.floorPositions.Length; i++)
        {
            Floor floor = GetFloorFromModels(blinkPointInfo.floorPositions[i], x0, y0, height, floorModels);
            floor.SetBlinkPoint(true);
        }

        // Set portal infos
        mapController.ClearPortalPointInfos(portalInfos.Length);
        for (int i = 0; i < portalInfos.Length; i++)
        {
            PortalInfo info = portalInfos[i];
            FloorPos pos = info.wallPos.floorPos;
            Floor floor = GetFloorFromModels(pos, x0, y0, height, floorModels);
            Transform wallParent = floor.GetWall((int)info.wallPos.wallDirection).transform.parent;

            PlayerEventHandler.PortalType type = info.portalType;
            switch (type)
            {
                case PlayerEventHandler.PortalType.DUNGEON:
                    for (int j = 0; j < wallParent.childCount; j++)
                    {
                        DungeonPortal dungeonPortal = wallParent.GetChild(j).GetComponent<DungeonPortal>();
                        dungeonPortal.SetupPortalInfo(info.targetStageId, info.targetPortalId);
                    }
                    break;
                case PlayerEventHandler.PortalType.SANCTUARY:
                    for (int j = 0; j < wallParent.childCount; j++)
                    {
                        SanctuaryPortal sanctuaryPortal = wallParent.GetChild(j).GetComponent<SanctuaryPortal>();
                        sanctuaryPortal.SetupPortalInfo();
                    }
                    break;
                default:
                    break;
            }

            mapController.AddPortalPointFloor(i, floor, info.startDirection);
        }

        // Set switch infos
        for (int i = 0; i < switchInfos.Length; i++)
        {
            SwitchInfo info = switchInfos[i];
            FloorPos pos = info.wallPos.floorPos;
            Floor floor = GetFloorFromModels(pos, x0, y0, height, floorModels);
            Switch targetSwitch = floor.GetWall((int)info.wallPos.wallDirection).transform.parent.GetChild(2).GetComponent<Switch>();
            IronBar[] targetIronBars = new IronBar[info.targetIronBarPositions.Length * 2];
            for (int j = 0; j < info.targetIronBarPositions.Length; j++)
            {
                WallPos ironBarWallPos = info.targetIronBarPositions[j];
                FloorPos ironBarFloorPos = ironBarWallPos.floorPos;
                Transform ironBarRoot = GetFloorFromModels(ironBarFloorPos, x0, y0, height, floorModels).GetWall((int)ironBarWallPos.wallDirection)
                    .transform.parent;
                for (int k = 0; k < ironBarRoot.childCount; k++)
                {
                    IronBar ironBar = ironBarRoot.GetChild(k).GetComponent<IronBar>();
                    targetIronBars[2 * j + k] = ironBar;
                }
            }

            Switch[] syncedSwitches = new Switch[info.syncedSwitchPositions.Length];
            for (int j = 0; j < syncedSwitches.Length; j++)
            {
                WallPos syncedSwitchWallPos = info.syncedSwitchPositions[j];
                FloorPos syncedSwitchFloorPos = syncedSwitchWallPos.floorPos;
                Switch syncedSwitch = GetFloorFromModels(syncedSwitchFloorPos, x0, y0, height, floorModels).GetWall((int)syncedSwitchWallPos.wallDirection)
                    .transform.parent.GetChild(2).GetComponent<Switch>();
                syncedSwitches[j] = syncedSwitch;
            }

            Switch[] assignedSwitches = new Switch[info.ironBarAssignedSwitchPositions.Length];
            for (int j = 0; j < assignedSwitches.Length; j++)
            {
                WallPos assignedSwitchWallPos = info.ironBarAssignedSwitchPositions[j];
                FloorPos assignedSwitchFloorPos = assignedSwitchWallPos.floorPos;
                Switch assignedSwitch = GetFloorFromModels(assignedSwitchFloorPos, x0, y0, height, floorModels).GetWall((int)assignedSwitchWallPos.wallDirection)
                    .transform.parent.GetChild(2).GetComponent<Switch>();
                assignedSwitches[j] = assignedSwitch;
            }

            targetSwitch.SetupSwitchInfo(targetIronBars, info.isForMultipleUsage, info.isPressed, syncedSwitches, assignedSwitches);
        }

        // Set ironBar infos
        for (int i = 0; i < ironBarInfos.Length; i++)
        {
            IronBarInfo info = ironBarInfos[i];
            WallPos ironBarWallPos = info.wallPos;
            FloorPos ironBarFloorPos = ironBarWallPos.floorPos;
            Transform ironBarRoot = GetFloorFromModels(ironBarFloorPos, x0, y0, height, floorModels).GetWall((int)ironBarWallPos.wallDirection)
                .transform.parent;

            for (int j = 0; j < ironBarRoot.childCount; j++)
            {
                IronBar ironBar = ironBarRoot.GetChild(j).GetComponent<IronBar>();
                ironBar.SetupIronBarInfo(info.openInDefault, info.isActivatedByTrigger);
            }
        }

        // Set tutorial infos
        for (int i = 0; i < tutorialInfos.Length; i++)
        {
            TutorialPointInfo info = tutorialInfos[i];
            Floor floor = GetFloorFromModels(info.floorPos, x0, y0, height, floorModels);
            floor.SetTutorialIndex(info.tutorialIndex);
        }

        // Set dialog event object
        for (int i = 0; i < dialogEventInfos.Length; i++)
        {
            DialogEventInfo info = dialogEventInfos[i];
            Floor floor = GetFloorFromModels(info.floorPos, x0, y0, height, floorModels);
            DialogEventObject dialog = Instantiate(dialogEventObjectPrefab, floor.transform);
            dialog.SetDialogInfo(info.dialogId, info.needToUpdateProgress);
            floor.SetInteractionObject(dialog);
        }
#endif
    }

    public void SaveCurrentWallFloorMaterialState()
    {
#if UNITY_EDITOR
        FloorWallMaterialData matData = new FloorWallMaterialData();
        
        Floor[] floorList = transform.GetChild(0).GetComponentsInChildren<Floor>(false);

        for (int  i = 0; i < floorList.Length; i++)
        {
            Floor floor = floorList[i];
            matData.AddFloorMat(floor.GetId(), floor.materialMainId);
        }

        Wall[] wallList = transform.GetChild(0).GetComponentsInChildren<Wall>(false);

        for (int i = 0; i < wallList.Length; i++)
        {
            Wall wall = wallList[i];
            matData.AddWallMat(wall.GetId(), wall.materialMainId, wall.materialSubId);
        }

        string dataJson = JsonUtility.ToJson(matData);
        string path = Application.dataPath + "/MapArtData/material" + stageId + ".json";
        File.WriteAllText(path, dataJson);
#endif
    }

    public void RestoreWallFloorMaterialState()
    {
#if UNITY_EDITOR
        string path = Application.dataPath + "/MapArtData/material" + stageId + ".json";
        string matDataJson = File.ReadAllText(path);
        FloorWallMaterialData matData = JsonUtility.FromJson<FloorWallMaterialData>(matDataJson);

        Floor[] floorList = transform.GetChild(0).GetComponentsInChildren<Floor>(false);

        for (int i = 0; i < floorList.Length; i++)
        {
            Floor floor = floorList[i];
            floor.SetFloorMaterial(floorMaterials[matData.GetFloorMatId(floor.GetId())]);
        }

        Wall[] wallList = transform.GetChild(0).GetComponentsInChildren<Wall>(false);

        for (int i = 0; i < wallList.Length; i++)
        {
            Wall wall = wallList[i];
            (int, int) wallMatId = matData.GetWallMatId(wall.GetId());
            if ((wallMatId.Item1 < 0 || wallMatId.Item2 < 0) && wallMatId.Item1 != -10)
            {
                continue;
            }
            SetWallMaterial(wall.transform.parent.gameObject, wallMatId.Item1, wallMatId.Item2);
        }
#endif
    }

    public void SaveCurrentMapDecorationState()
    {
#if UNITY_EDITOR
        MapDecorationData data = new MapDecorationData();
        MapDecoration[] decoList = decoParent.GetComponentsInChildren<MapDecoration>(false);

        for (int i = 0; i < decoList.Length; i++)
        {
            MapDecoration deco = decoList[i];
            data.AddDeco(deco);
        }

        string dataJson = JsonUtility.ToJson(data);
        string path = Application.dataPath + "/MapArtData/decoration" + stageId + ".json";
        File.WriteAllText(path, dataJson);
#endif
    }

    public void RestoreMapDecoration()
    {
#if UNITY_EDITOR
        string path = Application.dataPath + "/MapArtData/decoration" + stageId + ".json";
        string dataJson = File.ReadAllText(path);
        MapDecorationData data = JsonUtility.FromJson<MapDecorationData>(dataJson);

        for (int i = 0; i < data.decoTypeList.Count; i++)
        {
            GameObject decoPrefab = mapDecorations[(int)data.decoTypeList[i]];
            Instantiate(decoPrefab, data.positionList[i], data.rotationList[i], decoParent);
        }
#endif
    }

    private Floor GetFloorFromModels(FloorPos pos, int x0, int y0, int height, FloorModel[,] models)
    {
        int y = height - 1 - (pos.y - y0);
        int x = pos.x - x0;
        return models[y, x].tile;
    }

    private void SetWallObjectId(GameObject wall)
    {
        for (int i = 0; i < 2; i++)
        {
            Wall currentWall = wall.transform.GetChild(i).GetComponent<Wall>();
            string wallId = "W" + autoGeneratedId++;
            if (mapVersion > 0)
            {
                wallId += "v" + mapVersion;
            }
            currentWall.SetId(wallId);
        }        
    }

    private void SetWallMaterial(GameObject wall, int colorCode, int subCode)
    {
#if UNITY_EDITOR
        for (int i = 0; i < 2; i++)
        {
            Wall currentWall = wall.transform.GetChild(i).GetComponent<Wall>();
            if (colorCode >= 0 && subCode >= 0)
            {
                currentWall.SetMaterial(wallMaterials[colorCode].GetList()[subCode]);
            }
            else if (colorCode == -10)
            {
                currentWall.SetMaterial(transparentWallMaterial);
            }
            currentWall.materialMainId = colorCode;
            currentWall.materialSubId = subCode;
        }
#endif
    }

    private JObject getTilesFromJson()
    {
        string path = Application.dataPath + "/MapFile/" + jsonFileName;
        string json = File.ReadAllText(path);
        JObject loadData = JObject.Parse(json);
        JArray region = loadData["regions"] as JArray;
        JArray floors = region[0]["floors"] as JArray;
        return floors[0]["tiles"] as JObject;
    }

    // Reference: https://docs.google.com/presentation/d/1-Pzfay6yDkAzGIP47qxYhJhmiO4rN3z8/edit#slide=id.p2
    private WallType getWallTypeFromEdgeType(int edgeType)
    {
        switch (edgeType)
        {
            case 1: return new WallType(0);
            case 2: return new WallType(2);
            case 3: return new WallType(8);
            case 4: return new WallType(4);
            case 5: return new WallType(3, true);
            case 6: return new WallType(1);
            case 8: return new WallType(3);
            case 9: return new WallType(1, true);
            case 25: return new WallType(6);
            case 30: return new WallType(5, true);
            case 31: return new WallType(5);
            case 33: return new WallType(7);
            default:
                Debug.Log("edgeType " + edgeType);
                return new WallType(0);
        }
    }

    private int GetMaterialCode(int colorCode)
    {
        switch (colorCode)
        {
            case 1:
                return 0;
            case 71:
                return 1;
            case 74:
                return 2;
            case 105:
                return 3;
            case 83:
                return -10;
            default:
                return 0;
        }
    }
}

class FloorModel
{
    public Floor tile;
    public Wall right;
    public Wall bottom;
    public int rightChildIndex;
    public int bottomChildIndex;
    public int floorMaterialIndex;

    public int rightColorCode;
    public int rightColorSubCode;
    public int bottomColorCode;
    public int bottomColorSubCode;

    public FloorModel(
        Floor t, 
        Wall r, 
        Wall b, 
        int rIdx, 
        int bIdx, 
        int matIdx,
        int rColorCode,
        int rColorSubCode,
        int bColorCode,
        int bColorSubCode
    )
    {
        tile = t;
        right = r;
        bottom = b;
        rightChildIndex = rIdx;
        bottomChildIndex = bIdx;
        floorMaterialIndex = matIdx;
        rightColorCode = rColorCode;
        rightColorSubCode = rColorSubCode;
        bottomColorCode = bColorCode;
        bottomColorSubCode = bColorSubCode;
    }
}

class WallType
{
    public int prefabIndex;
    public bool isReverse;

    public WallType(int idx, bool isReverse = false)
    {
        prefabIndex = idx;
        this.isReverse = isReverse;
    }
}

[System.Serializable]
public class FloorPos
{
    public int x;
    public int y;
}

[System.Serializable]
public class WallPos
{
    public FloorPos floorPos;
    public Direction wallDirection;
}

[System.Serializable]
public class ThornFloorInfo
{
    public FloorPos[] floorPositions;

    public float popupDuration;
    public float hideDuration;
    public float[] startOffsets;

    public bool isActivatedByTrigger;
}

[System.Serializable]
public class ItemHolderInfo
{
    public int groupId;
    public FloorPos[] floorPositions;
    public int[] itemIds;
    public int[] golds;
    public bool isFixedItem;
}

[System.Serializable]
public class MonsterSpawnInfo
{
    public int groupId;
    public FloorPos[] floorPositions;
    public int[] monsterIds;
    public bool isFixedMonster;
    public bool isBossAttack;
}

[System.Serializable]
public class TriggerObjectInfo
{
    public FloorPos floorPos;
    public FloorPos[] thornFloorPositions;
    public WallPos[] ironBarPositions;
    public FloorPos unLockFloorPos;
}

[System.Serializable]
public class TimerObjectInfo
{
    public FloorPos floorPos;
    public FloorPos[] thornFloorPositions;
    public WallPos[] ironBarPositions;
    public float timeToStopTimer;
}

[System.Serializable]
public class BlinkPointInfo
{
    public FloorPos[] floorPositions;
}

[System.Serializable]
public class StartPointInfo
{
    public FloorPos floorPosition;
    public Direction startDirection;
}

[System.Serializable]
public class PortalInfo
{
    public WallPos wallPos;
    public PlayerEventHandler.PortalType portalType;
    public int targetPortalId;
    public int targetStageId;
    public Direction startDirection;
}

[System.Serializable]
public class SwitchInfo
{
    public WallPos wallPos;
    public WallPos[] targetIronBarPositions;
    public bool isForMultipleUsage;
    public bool isPressed;
    public WallPos[] syncedSwitchPositions;
    public WallPos[] ironBarAssignedSwitchPositions;
}

[System.Serializable]
public class IronBarInfo
{
    public WallPos wallPos;
    public bool openInDefault;
    public bool isActivatedByTrigger;
}

[System.Serializable]
public class TutorialPointInfo
{
    public FloorPos floorPos;
    public int tutorialIndex;
}

[System.Serializable]
public class DialogEventInfo
{
    public FloorPos floorPos;
    public string dialogId;
    public bool needToUpdateProgress;
}

[System.Serializable]
public class FloorWallMaterialData : ISerializationCallbackReceiver
{
    [SerializeField] private List<string> floorIds = new List<string>();
    [SerializeField] private List<int> floorMatIds = new List<int>();

    [SerializeField] private List<string> wallIds = new List<string>();
    [SerializeField] private List<int> wallMatMainIds = new List<int>();
    [SerializeField] private List<int> wallMatSubIds = new List<int>();

    private Dictionary<string, int> floorMatDict;
    private Dictionary<string, (int, int)> wallMatDict;

    public void AddFloorMat(string floorId, int matId)
    {
        floorIds.Add(floorId);
        floorMatIds.Add(matId);
    }

    public void AddWallMat(string wallId, int matMainId, int matSubId)
    {
        wallIds.Add(wallId);
        wallMatMainIds.Add(matMainId);
        wallMatSubIds.Add(matSubId);
    }

    public int GetFloorMatId(string floorId)
    {
        return floorMatDict[floorId];
    }

    public (int, int) GetWallMatId(string wallId)
    {
        return wallMatDict[wallId];
    }

    public void OnAfterDeserialize()
    {
        floorMatDict = new Dictionary<string, int>();
        wallMatDict = new Dictionary<string, (int, int)>();

        for (int i = 0; i < floorIds.Count; i++)
        {
            floorMatDict[floorIds[i]] = floorMatIds[i];
        }

        for (int i = 0; i < wallIds.Count; i++)
        {
            wallMatDict[wallIds[i]] = (wallMatMainIds[i], wallMatSubIds[i]);
        }
    }

    public void OnBeforeSerialize()
    {
    }
}

[System.Serializable]
public class MapDecorationData
{
    public List<MapDecoration.DecoType> decoTypeList = new List<MapDecoration.DecoType>();
    public List<Vector3> positionList = new List<Vector3>();
    public List<Quaternion> rotationList = new List<Quaternion>();

    public void AddDeco(MapDecoration deco)
    {
        decoTypeList.Add(deco.type);
        positionList.Add(deco.transform.localPosition);
        rotationList.Add(deco.transform.localRotation);
    }
}